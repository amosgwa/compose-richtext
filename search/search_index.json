{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Compose Richtext is a collection of Compose libraries for working with rich text formatting and documents. </p> <p><code>richtext-ui</code>, <code>richtext-markdown</code>, <code>richtext-commonmark</code>, and <code>richtext-ui-material</code>|<code>richtext-ui-material3</code> are Kotlin Multiplatform(KMP) Compose Libraries. All these modules can be used in Android and Desktop Compose apps. </p> <p>Each library is documented separately, see the navigation menu for the list. This site also includes an API reference.</p> <p>Warning</p> <p>This project is currently experimental and mostly just a proof-of-concept at this point. There are no tests and some things might be broken or very non-performant.</p> <p>The API may also change between releases without deprecation cycles.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>These libraries are published to Maven Central, so just add a Gradle dependency:</p> <pre><code>dependencies {\n  implementation(\"com.halilibo.compose-richtext:&lt;LIBRARY-ARTIFACT&gt;:${richtext_version}\")\n}\n</code></pre> <p>There is no difference for KMP artifacts. For instance, if you are adding <code>richtext-ui</code> to a Kotlin Multiplatform module</p> <pre><code>val commonMain by getting {\n  dependencies {\n    implementation(\"com.halilibo.compose-richtext:richtext-ui:${richtext_version}\")\n  }\n}\n</code></pre>"},{"location":"#library-artifacts","title":"Library Artifacts","text":"<p>The <code>LIBRARY_ARTIFACT</code>s for each individual library can be found on their respective pages.</p>"},{"location":"#samples","title":"Samples","text":"<p>Please check out Android and Desktop projects to see various use cases of RichText in both platforms.</p>"},{"location":"printing/","title":"Printing","text":"<p>A library for using Compose to generated printed documents, using Android's printing services.</p>"},{"location":"printing/#gradle","title":"Gradle","text":"<pre><code>dependencies {\n  implementation \"com.halilibo.compose-richtext:printing:${richtext_version}\"\n}\n</code></pre>"},{"location":"printing/#usage","title":"Usage","text":"<p>There are multiple entry points into this library. See their kdoc for usage and parameter documentation, and take a look at the samples for example code.</p>"},{"location":"printing/#printable","title":"<code>Printable</code>","text":"<p>This is the simplest entry point. It's a composable function that displays its children on screen, but can also print itself. Printing is triggered by the <code>PrintableController</code> passed to <code>Printable</code>. <code>PrintableController</code> is a hoisted state type, just like <code>ScrollState</code>, created by calling <code>rememberPrintableController</code>.</p> <pre><code>val printController = rememberPrintableController()\nPrintable(printController) {\n  ScrollableColumn {\n    Card { \u2026 }\n    Card { \u2026 }\n    Button(onClick = { printController.print(\"sales report\") }) { \u2026 }\n  }\n}\n</code></pre>"},{"location":"printing/#composeprintadapter","title":"<code>ComposePrintAdapter</code>","text":"<p>This is a <code>PrintDocumentAdapter</code> that can be used directly with Android's printing APIs to print any composable function. It takes, at minimum, the <code>ComponentActivity</code> that owns the print adapter (as required by Android's printing framework), a string name for the document, and the composable function that defines the content to print. See the linked API documentation for more details.</p>"},{"location":"printing/#paged","title":"<code>Paged</code>","text":"<p>This is another composable, but doesn't actually have anything to do with printing. Conceptually it's similar to a <code>ScrollableColumn</code> \u2013 it lays its contents out at full height, then can display them at various vertical offsets. However, it also tries to ensure that no composables are clipped at the bottom, by measuring where all the leaf composables (those without any children) are located clipping the content before them. It is used by the printing APIs to try to ensure that composable content looks decent when split into printer pages.</p> <p>See the <code>PagedSample</code> for more information.</p>"},{"location":"printing/#demo","title":"Demo","text":"<p>The <code>DocumentSample</code> tries to match the style of one of the Google Docs templates. It looks great on small phone screens, but also prints:</p> <p></p>"},{"location":"richtext-commonmark/","title":"Markdown","text":"<p>Library for parsing and rendering Markdown in Compose using CommonMark library/spec to parse, and <code>richtext-ui</code> to render.</p>"},{"location":"richtext-commonmark/#gradle","title":"Gradle","text":"<pre><code>dependencies {\n  implementation(\"com.halilibo.compose-richtext:richtext-commonmark:${richtext_version}\")\n}\n</code></pre>"},{"location":"richtext-commonmark/#parsing","title":"Parsing","text":"<p><code>richtext-markdown</code> module renders a given Markdown Abstract Syntax Tree. It accepts a root  <code>AstNode</code>. This library gives you a parser called <code>CommonmarkAstNodeParser</code> to easily convert any  String to an <code>AstNode</code> that represents the Markdown tree.</p> <pre><code>    val parser = CommonmarkAstNodeParser()\n    val astNode = parser.parse(\n        \"\"\"\n        # Demo\n\n        Emphasis, aka italics, with *asterisks* or _underscores_. Strong emphasis, aka bold, with **asterisks** or __underscores__. Combined emphasis with **asterisks and _underscores_**. [Links with two blocks, text in square-brackets, destination is in parentheses.](https://www.example.com). Inline `code` has `back-ticks around` it.\n\n        1. First ordered list item\n        2. Another item\n            * Unordered sub-list.\n        3. And another item.\n            You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown).\n\n        * Unordered list can use asterisks\n        - Or minuses\n        + Or pluses\n        \"\"\".trimIndent()\n    )\n    // ...\n\n    RichTextScope.BasicMarkdown(astNode)\n</code></pre>"},{"location":"richtext-commonmark/#rendering","title":"Rendering","text":"<p>The simplest way to render markdown is just pass a string to the <code>Markdown</code> composable under RichText scope:</p> <pre><code>RichText(\n  modifier = Modifier.padding(16.dp)\n) {\n  Markdown(\n    \"\"\"\n    # Demo\n\n    Emphasis, aka italics, with *asterisks* or _underscores_. Strong emphasis, aka bold, with **asterisks** or __underscores__. Combined emphasis with **asterisks and _underscores_**. [Links with two blocks, text in square-brackets, destination is in parentheses.](https://www.example.com). Inline `code` has `back-ticks around` it.\n\n    1. First ordered list item\n    2. Another item\n        * Unordered sub-list.\n    3. And another item.\n        You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown).\n\n    * Unordered list can use asterisks\n    - Or minuses\n    + Or pluses\n    ---\n\n    ```javascript\n    var s = \"code blocks use monospace font\";\n    alert(s);\n    ```\n\n    Markdown | Table | Extension\n    --- | --- | ---\n    *renders* | `beautiful images` | ![random image](https://picsum.photos/seed/picsum/400/400 \"Text 1\")\n    1 | 2 | 3\n\n    &gt; Blockquotes are very handy in email to emulate reply text.\n    &gt; This line is part of the same quote.\n    \"\"\".trimIndent()\n  )\n}\n</code></pre> <p>Which produces something like this:</p> <p></p>"},{"location":"richtext-commonmark/#markdownparseoptions","title":"<code>MarkdownParseOptions</code>","text":"<p>Passing <code>MarkdownParseOptions</code> into either <code>Markdown</code> composable or <code>CommonmarkAstNodeParser.parse</code> method provides the ability to control some aspects of the markdown parser:</p> <pre><code>val markdownParseOptions = MarkdownParseOptions(\n  autolink = false\n)\n\nMarkdown(\n  markdownParseOptions = markdownParseOptions\n)\n</code></pre>"},{"location":"richtext-markdown/","title":"Markdown","text":"<p>Library for rendering Markdown tree that is defined as an <code>AstNode</code>. This module would be useless for someone who is looking to just render a Markdown string. Please take a look to  <code>richtext-commonmark</code> for such features. <code>richtext-markdown</code> behaves as sort of a building block. You can create your own parser or use 3rd party ones that converts any Markdown string to an  <code>AstNode</code> tree.</p>"},{"location":"richtext-markdown/#gradle","title":"Gradle","text":"<pre><code>dependencies {\n  implementation(\"com.halilibo.compose-richtext:richtext-markdown:${richtext_version}\")\n}\n</code></pre>"},{"location":"richtext-markdown/#rendering","title":"Rendering","text":"<p>The simplest way to render markdown is just pass an <code>AstNode</code> to the <code>Markdown</code> composable under RichText scope:</p> <pre><code>RichText(\n  modifier = Modifier.padding(16.dp)\n) {\n  // requires richtext-commonmark module.\n  val parser = remember(options) { CommonmarkAstNodeParser(options) }\n  val astNode = remember(parser) {\n    parser.parse(\n      \"\"\"\n        # Demo\n\n        Emphasis, aka italics, with *asterisks* or _underscores_. Strong emphasis, aka bold, with **asterisks** or __underscores__. Combined emphasis with **asterisks and _underscores_**. [Links with two blocks, text in square-brackets, destination is in parentheses.](https://www.example.com). Inline `code` has `back-ticks around` it.\n\n        1. First ordered list item\n        2. Another item\n            * Unordered sub-list.\n        3. And another item.\n            You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown).\n\n        * Unordered list can use asterisks\n        - Or minuses\n        + Or pluses\n        \"\"\".trimIndent()\n    )\n  }\n  BasicMarkdown(astNode)\n}\n</code></pre>"},{"location":"richtext-ui-material/","title":"Richtext UI Material","text":"<p>Library that makes RichText compatible with Material design in Compose.</p>"},{"location":"richtext-ui-material/#gradle","title":"Gradle","text":"<pre><code>dependencies {\n  implementation(\"com.halilibo.compose-richtext:richtext-ui-material:${richtext_version}\")\n}\n</code></pre>"},{"location":"richtext-ui-material/#usage","title":"Usage","text":"<p>Material RichText library provides a single composable called <code>RichText</code> which automatically passes down Material theming attributes to <code>BasicRichText</code>. </p>"},{"location":"richtext-ui-material/#richtext","title":"<code>RichText</code>","text":"<p><code>RichText</code> composable wraps around regular <code>BasicRichText</code> while introducing the necessary integration dependencies. <code>RichText</code> shares the exact arguments with regular <code>BasicRichText</code>.</p> <pre><code>RichText(modifier = Modifier.background(color = Color.White)) {\n  Heading(0, \"Paragraphs\")\n  Text(\"Simple paragraph.\")\n  ...\n}\n</code></pre>"},{"location":"richtext-ui-material3/","title":"Richtext UI Material 3","text":"<p>Library that makes RichText compatible with Material design in Compose.</p>"},{"location":"richtext-ui-material3/#gradle","title":"Gradle","text":"<pre><code>dependencies {\n  implementation(\"com.halilibo.compose-richtext:richtext-ui-material3:${richtext_version}\")\n}\n</code></pre>"},{"location":"richtext-ui-material3/#usage","title":"Usage","text":"<p>Material3 RichText library provides a single composable called <code>RichText</code> which automatically passes down Material3 theming attributes to <code>BasicRichText</code>.</p>"},{"location":"richtext-ui-material3/#richtext","title":"<code>RichText</code>","text":"<p><code>RichText</code> composable wraps around regular <code>BasicRichText</code> while introducing the necessary integration dependencies. <code>RichText</code> shares the exact arguments with regular <code>BasicRichText</code>.</p> <pre><code>RichText(modifier = Modifier.background(color = Color.White)) {\n  Heading(0, \"Paragraphs\")\n  Text(\"Simple paragraph.\")\n  ...\n}\n</code></pre>"},{"location":"richtext-ui/","title":"Richtext UI","text":"<p>A library of composables for formatting text using higher-level concepts than are supported by compose foundation, such as \"bullet lists\" and \"headings\".</p> <p>RichText UI is a base library that is non-opinionated about higher level design requirements. If you are already using <code>MaterialTheme</code> in your compose app, you can jump to RichText UI Material for quick start. There is also Material3 flavor at RichText UI Material3</p>"},{"location":"richtext-ui/#gradle","title":"Gradle","text":"<pre><code>dependencies {\n  implementation(\"com.halilibo.compose-richtext:richtext-ui:${richtext_version}\")\n}\n</code></pre>"},{"location":"richtext-ui/#basicrichtext","title":"<code>BasicRichText</code>","text":"<p>Richtext UI does not depend on Material artifact of Compose. Design agnostic API allows anyone to adopt RichText UI and its extensions like Markdown to their own design and typography systems. Hence, just like <code>foundation</code> and <code>material</code> modules of Compose, this library also names the  building block with <code>Basic</code> prefix.</p> <p>If you are planning to adopt RichText within your design system, please go ahead and check out <code>RichText Material</code> for inspiration.</p>"},{"location":"richtext-ui/#richtextscope","title":"<code>RichTextScope</code>","text":"<p><code>RichTextScope</code> is a context wrapper around composables that integrate and play well within RichText content. </p>"},{"location":"richtext-ui/#richtextthemeprovider","title":"<code>RichTextThemeProvider</code>","text":"<p>Entry point for integrating app's own typography and theme system with BasicRichText.</p> <p>API for this integration is highly influenced by how compose-material theming is designed. RichText library assumes that almost all Theme/Design systems would have composition locals that provide a TextStyle downstream.</p> <p>Moreover, text style should not include text color by best practice. Content color exists to figure out text color in the current context. Light/Dark theming leverages content color to influence not just text but other parts of theming as well.</p>"},{"location":"richtext-ui/#example","title":"Example","text":"<p>Open the <code>Demo.kt</code> file in the <code>sample</code> module to play with this. Although the mentioned demo uses Material integrated version of <code>RichText</code>, they share exactly the same API.</p> <pre><code>BasicRichText(\n  modifier = Modifier.background(color = Color.White)\n) {\n  Heading(0, \"Paragraphs\")\n  Text(\"Simple paragraph.\")\n  Text(\"Paragraph with\\nmultiple lines.\")\n  Text(\"Paragraph with really long line that should be getting wrapped.\")\n\n  Heading(0, \"Lists\")\n  Heading(1, \"Unordered\")\n  ListDemo(listType = Unordered)\n  Heading(1, \"Ordered\")\n  ListDemo(listType = Ordered)\n\n  Heading(0, \"Horizontal Line\")\n  Text(\"Above line\")\n  HorizontalRule()\n  Text(\"Below line\")\n\n  Heading(0, \"Code Block\")\n  CodeBlock(\n    \"\"\"\n      {\n        \"Hello\": \"world!\"\n      }\n    \"\"\".trimIndent()\n  )\n\n  Heading(0, \"Block Quote\")\n  BlockQuote {\n    Text(\"These paragraphs are quoted.\")\n    Text(\"More text.\")\n    BlockQuote {\n      Text(\"Nested block quote.\")\n    }\n  }\n\n  Heading(0, \"Info Panel\")\n  InfoPanel(InfoPanelType.Primary, \"Only text primary info panel\")\n  InfoPanel(InfoPanelType.Success) {\n    Column {\n      Text(\"Successfully sent some data\")\n      HorizontalRule()\n      BlockQuote {\n        Text(\"This is a quote\")\n      }\n    }\n  }\n\n  Heading(0, \"Table\")\n  Table(headerRow = {\n    cell { Text(\"Column 1\") }\n    cell { Text(\"Column 2\") }\n  }) {\n    row {\n      cell { Text(\"Hello\") }\n      cell {\n        CodeBlock(\"Foo bar\")\n      }\n    }\n    row {\n      cell {\n        BlockQuote {\n          Text(\"Stuff\")\n        }\n      }\n      cell { Text(\"Hello world this is a really long line that is going to wrap hopefully\") }\n    }\n  }\n}\n</code></pre> <p>Looks like this:</p> <p></p>"},{"location":"slideshow/","title":"Slideshow","text":"<p>A library for presenting simple Powerpoint-like slideshows from a phone (e.g. you can share your phone screen to a Google Hangout and present that way). Slides can contain any composable content, although a few pre-fab scaffolds are provided for common slide layouts.</p> <p></p>"},{"location":"slideshow/#gradle","title":"Gradle","text":"<pre><code>dependencies {\n  implementation \"com.halilibo.compose-richtext:slideshow:${richtext_version}\"\n}\n</code></pre>"},{"location":"slideshow/#setting-up-a-slideshow","title":"Setting up a slideshow","text":"<p>There is a single, simple entry point to this library, that takes a vararg of composable functions that define your slides:</p> <pre><code>Slideshow(\n  { /* First slide. */ },\n  { /* Second slide. */ },\n  { /* etc\u2026 */ },\n)\n</code></pre> <p>The <code>Slideshow</code> composable will automatically lock your phone to landscape and enter immersive fullscreen while it's composed. You can tap anywhere on the left or right of the screen to navigate. Currently the only supported slide transition is crossfade, but it shouldn't be hard to make the library more pluggable and support more advanced transition libraries (like this one).</p>"},{"location":"slideshow/#creating-slides","title":"Creating slides","text":"<p>Individual slides are centered by default, but you can put whatever you want in them. The library has a few scaffolds for common slide layouts that you might find useful.</p>"},{"location":"slideshow/#titleslide","title":"<code>TitleSlide</code>","text":"<p>Very simple: a title and a subtitle, centered.</p> <pre><code>Slideshow(\n  {\n    TitleSlide(\n      title = { Text(\"Title\") },\n      subtitle = { Text(\"Subtitle\") },\n    )\n  },\n)\n</code></pre>"},{"location":"slideshow/#bodyslide","title":"<code>BodySlide</code>","text":"<p>The <code>BodySlide</code> composable gives you a top header, bottom footer, and middle body slot to put stuff into.</p> <pre><code>Slideshow(\n  { \u2026 },\n  {\n    BodySlide(\n      header = { Text(\"Header\") },\n      footer = { Text(\"Footer\") },\n      body = {\n        WebComponent(\u2026)\n        // or something\n      },\n    )\n  },\n)\n</code></pre> <p>Slide scaffolds like <code>BodySlide</code> and <code>TitleSlide</code>, as well as some other aspects of slideshow formatting like background color, are controlled by passing a <code>SlideshowTheme</code> to the <code>Slideshow</code> composable.</p>"},{"location":"slideshow/#animating-content-on-a-single-slide","title":"Animating content on a single slide","text":"<p>A corporate presentation wouldn't be a presentation without obtuse visual effects. The <code>NavigableContentContainer</code> composable is a flexible primitive for building such effects. It takes a slot inside of which <code>NavigableContent</code> composables define blocks of content that will be shown or hidden by slide navigation. Each <code>NavigableContent</code> block gets a <code>State&lt;Boolean&gt;</code> indicating whether content should be shown or not, and is free to show or hide content however it likes. For example, Compose comes with the <code>AnimatedVisibility</code> composable out of the box, which plays very nicely with this API. See the <code>SlideshowSample</code> to see it in action.</p> <pre><code>NavigableContentContainer {\n  Column {\n    // Show this right away.\n    Text(\"First paragraph\")\n\n    // Only show this after tapping to advance the show, then fade it in.\n    NavigableContent { visible -&gt;\n      val opacity = animate(if (visible) 1f else 0f)\n      Text(\"Second paragraph\", Modifier.drawOpacity(opacity))\n    }\n  }\n}\n</code></pre>"},{"location":"slideshow/#running-the-show","title":"Running the show","text":"<p>If you're in the middle of a presentation and lose your place, just drag up anywhere on the screen. A slider and preview will pop up to let you scrub through the deck.</p> <p></p>"}]}